import fs from "node:fs";
import path from "node:path";
import { dedupeArray, unionType } from "./utils.ts";

console.log("Generating samples map");

const root = path.resolve("..", "data");

const techniqueEntries: Record<string, Record<string, string[]>> = {};

const locales = fs.readdirSync(root).filter((item) => {
  const fullPath = path.join(root, item);
  return fs.statSync(fullPath).isDirectory();
});

console.log(`[Info] Found ${locales.length} locale(s): ${locales}.`);

for (const locale of locales) {
  techniqueEntries[locale] = {};
  const localePath = path.join(root, locale);

  // Read all technique directories inside the locale
  const techniques = fs.readdirSync(localePath).filter((item) => {
    const fullPath = path.join(localePath, item);
    return fs.statSync(fullPath).isDirectory();
  });

  console.log(
    `[Info] Found ${techniques.length} technique(s) for locale ${locale}.`,
  );

  for (const technique of techniques) {
    const techniquePath = path.join(localePath, technique);

    const { introduction, sampleFiles } = fs
      .readdirSync(techniquePath)
      .filter((sample) => {
        const fullPath = path.join(techniquePath, sample);
        const isMarkdownFile = path.extname(fullPath).toLowerCase() === ".md";

        return fs.statSync(fullPath).isFile() && isMarkdownFile;
      })
      .map((sample) => path.join("data", locale, technique, sample))
      .reduce<{ introduction: string | null; sampleFiles: string[] }>(
        (acc, item) => {
          const isReadme = path.basename(item).toLowerCase() === "readme.md";
          if (isReadme) {
            return { ...acc, introduction: item };
          }

          return { ...acc, sampleFiles: [...acc.sampleFiles, item] };
        },
        { introduction: null, sampleFiles: [] },
      );

    if (!introduction) {
      console.warn(
        `[Warn]: skipping ${technique} because it does not contain a README.md file`,
      );
      continue;
    }

    techniqueEntries[locale][technique] = [];
    for (const sampleFile of sampleFiles) {
      const framework = path.parse(sampleFile).name;
      techniqueEntries[locale][technique].push(framework);
    }
  }
}

const techniques = dedupeArray(
  Object.values(techniqueEntries).flatMap(Object.keys),
);

const frameworks = dedupeArray(
  Object.values(techniqueEntries).map(Object.values).flat(2),
);

const fileContent = `// This file is generated automatically. Do not edit manually.
// A new file can be generated by running "npm run generate-samples-map" in the "/scripts" directory

${unionType(true, "Locale", locales)}
${unionType(true, "Technique", techniques)}
${unionType(true, "Framework", frameworks)}

export const samples: Record<Locale, Partial<Record<Technique, Framework[]>>> = ${JSON.stringify(techniqueEntries, null, 2)};
`;

fs.writeFileSync("../lib/src/generated.ts", fileContent);
